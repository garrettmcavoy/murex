// node_modules/threejs-object-controls/ObjectControls.js
function ObjectControls(camera, domElement, objectToMove) {
  this.setObjectToMove = function(newMesh) {
    mesh = newMesh;
  };
  this.getObjectToMove = function() {
    return mesh;
  };
  this.setZoomSpeed = function(newZoomSpeed) {
    zoomSpeed = newZoomSpeed;
  };
  this.setDistance = function(min, max) {
    minDistance = min;
    maxDistance = max;
  };
  this.setRotationSpeed = function(newRotationSpeed) {
    rotationSpeed = newRotationSpeed;
  };
  this.setRotationSpeedTouchDevices = function(newRotationSpeed) {
    rotationSpeedTouchDevices = newRotationSpeed;
  };
  this.enableVerticalRotation = function() {
    verticalRotationEnabled = true;
  };
  this.disableVerticalRotation = function() {
    verticalRotationEnabled = false;
  };
  this.enableHorizontalRotation = function() {
    horizontalRotationEnabled = true;
  };
  this.disableHorizontalRotation = function() {
    horizontalRotationEnabled = false;
  };
  this.setMaxVerticalRotationAngle = function(min, max) {
    MAX_ROTATON_ANGLES.x.from = min;
    MAX_ROTATON_ANGLES.x.to = max;
    MAX_ROTATON_ANGLES.x.enabled = true;
  };
  this.setMaxHorizontalRotationAngle = function(min, max) {
    MAX_ROTATON_ANGLES.y.from = min;
    MAX_ROTATON_ANGLES.y.to = max;
    MAX_ROTATON_ANGLES.y.enabled = true;
  };
  this.disableMaxHorizontalAngleRotation = function() {
    MAX_ROTATON_ANGLES.y.enabled = false;
  };
  this.disableMaxVerticalAngleRotation = function() {
    MAX_ROTATON_ANGLES.x.enabled = false;
  };
  this.disableZoom = function() {
    zoomEnabled = false;
  };
  this.enableZoom = function() {
    zoomEnabled = true;
  };
  this.isUserInteractionActive = function() {
    return isDragging;
  };
  domElement = domElement !== void 0 ? domElement : document;
  const MAX_ROTATON_ANGLES = {
    x: {
      // Vertical from bottom to top.
      enabled: false,
      from: Math.PI / 8,
      to: Math.PI / 8
    },
    y: {
      // Horizontal from left to right.
      enabled: false,
      from: Math.PI / 4,
      to: Math.PI / 4
    }
  };
  let flag, mesh = objectToMove, maxDistance = 15, minDistance = 6, zoomSpeed = 0.5, rotationSpeed = 0.05, rotationSpeedTouchDevices = 0.05, isDragging = false, verticalRotationEnabled = false, horizontalRotationEnabled = true, zoomEnabled = true, mouseFlags = { MOUSEDOWN: 0, MOUSEMOVE: 1 }, previousMousePosition = { x: 0, y: 0 }, prevZoomDiff = { X: null, Y: null }, currentTouches = [];
  function zoomIn() {
    camera.position.z -= zoomSpeed;
  }
  function zoomOut() {
    camera.position.z += zoomSpeed;
  }
  function rotateVertical(deltaMove, mesh2) {
    if (mesh2.length > 1) {
      for (let i = 0; i < mesh2.length; i++) {
        rotateVertical(deltaMove, mesh2[i]);
      }
      return;
    }
    mesh2.rotation.x += Math.sign(deltaMove.y) * rotationSpeed;
  }
  function rotateVerticalTouch(deltaMove, mesh2) {
    if (mesh2.length > 1) {
      for (let i = 0; i < mesh2.length; i++) {
        rotateVerticalTouch(deltaMove, mesh2[i]);
      }
      return;
    }
    mesh2.rotation.x += Math.sign(deltaMove.y) * rotationSpeedTouchDevices;
  }
  function rotateHorizontal(deltaMove, mesh2) {
    if (mesh2.length > 1) {
      for (let i = 0; i < mesh2.length; i++) {
        rotateHorizontal(deltaMove, mesh2[i]);
      }
      return;
    }
    mesh2.rotation.y += Math.sign(deltaMove.x) * rotationSpeed;
  }
  function rotateHorizontalTouch(deltaMove, mesh2) {
    if (mesh2.length > 1) {
      for (let i = 0; i < mesh2.length; i++) {
        rotateHorizontalTouch(deltaMove, mesh2[i]);
      }
      return;
    }
    mesh2.rotation.y += Math.sign(deltaMove.x) * rotationSpeedTouchDevices;
  }
  function isWithinMaxAngle(delta, axe) {
    if (MAX_ROTATON_ANGLES[axe].enabled) {
      if (mesh.length > 1) {
        let condition = true;
        for (let i = 0; i < mesh.length; i++) {
          if (!condition)
            return false;
          if (MAX_ROTATON_ANGLES[axe].enabled) {
            condition = isRotationWithinMaxAngles(mesh[i], delta, axe);
          }
        }
        return condition;
      }
      return isRotationWithinMaxAngles(mesh, delta, axe);
    }
    return true;
  }
  function isRotationWithinMaxAngles(meshToRotate, delta, axe) {
    return MAX_ROTATON_ANGLES[axe].from * -1 < meshToRotate.rotation[axe] + delta && meshToRotate.rotation[axe] + delta < MAX_ROTATON_ANGLES[axe].to ? true : false;
  }
  function resetMousePosition() {
    previousMousePosition = { x: 0, y: 0 };
  }
  function mouseDown(e) {
    isDragging = true;
    flag = mouseFlags.MOUSEDOWN;
  }
  function mouseMove(e) {
    if (isDragging) {
      const deltaMove = {
        x: e.offsetX - previousMousePosition.x,
        y: e.offsetY - previousMousePosition.y
      };
      previousMousePosition = { x: e.offsetX, y: e.offsetY };
      if (horizontalRotationEnabled && deltaMove.x != 0) {
        if (!isWithinMaxAngle(Math.sign(deltaMove.x) * rotationSpeed, "y"))
          return;
        rotateHorizontal(deltaMove, mesh);
        flag = mouseFlags.MOUSEMOVE;
      }
      if (verticalRotationEnabled && deltaMove.y != 0) {
        if (!isWithinMaxAngle(Math.sign(deltaMove.y) * rotationSpeed, "x"))
          return;
        rotateVertical(deltaMove, mesh);
        flag = mouseFlags.MOUSEMOVE;
      }
    }
  }
  function mouseUp() {
    isDragging = false;
    resetMousePosition();
  }
  function wheel(e) {
    if (!zoomEnabled)
      return;
    const delta = e.wheelDelta ? e.wheelDelta : e.deltaY * -1;
    if (delta > 0 && camera.position.z > minDistance) {
      zoomIn();
    } else if (delta < 0 && camera.position.z < maxDistance) {
      zoomOut();
    }
  }
  function onTouchStart(e) {
    e.preventDefault();
    flag = mouseFlags.MOUSEDOWN;
    if (e.touches.length === 2) {
      prevZoomDiff.X = Math.abs(e.touches[0].clientX - e.touches[1].clientX);
      prevZoomDiff.Y = Math.abs(e.touches[0].clientY - e.touches[1].clientY);
      currentTouches = new Array(2);
    } else {
      previousMousePosition = { x: e.touches[0].pageX, y: e.touches[0].pageY };
    }
  }
  function onTouchEnd(e) {
    prevZoomDiff.X = null;
    prevZoomDiff.Y = null;
    if (currentTouches.length > 0) {
      currentTouches.pop();
    } else {
      currentTouches = [];
    }
    e.preventDefault();
    if (flag === mouseFlags.MOUSEDOWN) {
    } else if (flag === mouseFlags.MOUSEMOVE) {
    }
    resetMousePosition();
  }
  function onTouchMove(e) {
    e.preventDefault();
    flag = mouseFlags.MOUSEMOVE;
    if (e.touches.length === 2 && zoomEnabled) {
      currentTouches = new Array(2);
      const curDiffX = Math.abs(e.touches[0].clientX - e.touches[1].clientX);
      const curDiffY = Math.abs(e.touches[0].clientY - e.touches[1].clientY);
      if (prevZoomDiff && prevZoomDiff.X > 0 && prevZoomDiff.Y > 0) {
        if (curDiffX > prevZoomDiff.X && curDiffY > prevZoomDiff.Y && camera.position.z > minDistance) {
          zoomIn();
        } else if (curDiffX < prevZoomDiff.X && camera.position.z < maxDistance && curDiffY < prevZoomDiff.Y) {
          zoomOut();
        }
      }
      prevZoomDiff.X = curDiffX;
      prevZoomDiff.Y = curDiffY;
    } else if (currentTouches.length === 0) {
      prevZoomDiff.X = null;
      prevZoomDiff.Y = null;
      const deltaMove = {
        x: e.touches[0].pageX - previousMousePosition.x,
        y: e.touches[0].pageY - previousMousePosition.y
      };
      previousMousePosition = { x: e.touches[0].pageX, y: e.touches[0].pageY };
      if (horizontalRotationEnabled && deltaMove.x != 0) {
        if (!isWithinMaxAngle(
          Math.sign(deltaMove.x) * rotationSpeedTouchDevices,
          "y"
        ))
          return;
        rotateHorizontalTouch(deltaMove, mesh);
      }
      if (verticalRotationEnabled && deltaMove.y != 0) {
        if (!isWithinMaxAngle(
          Math.sign(deltaMove.y) * rotationSpeedTouchDevices,
          "x"
        ))
          return;
        rotateVerticalTouch(deltaMove, mesh);
      }
    }
  }
  domElement.addEventListener("mousedown", mouseDown, false);
  domElement.addEventListener("mousemove", mouseMove, false);
  domElement.addEventListener("mouseup", mouseUp, false);
  domElement.addEventListener("mouseout", mouseUp, false);
  domElement.addEventListener("wheel", wheel, false);
  domElement.addEventListener("touchstart", onTouchStart, false);
  domElement.addEventListener("touchmove", onTouchMove, false);
  domElement.addEventListener("touchend", onTouchEnd, false);
}
export {
  ObjectControls
};
//# sourceMappingURL=threejs-object-controls.js.map
